<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Resistor Value Reader</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #1a1a2e;
    --surface: #16213e;
    --surface2: #0f3460;
    --accent: #e94560;
    --text: #eee;
    --text-dim: #999;
    --radius: 12px;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100dvh;
    overflow-x: hidden;
  }

  header {
    text-align: center;
    padding: 16px 16px 8px;
  }
  header h1 { font-size: 1.3rem; font-weight: 700; letter-spacing: -0.02em; }
  header p { font-size: 0.8rem; color: var(--text-dim); margin-top: 2px; }

  main {
    max-width: 500px;
    margin: 0 auto;
    padding: 0 12px 24px;
  }

  /* Camera Section */
  .camera-container {
    position: relative;
    width: 100%;
    aspect-ratio: 4 / 3;
    background: #000;
    border-radius: var(--radius);
    overflow: hidden;
    margin-bottom: 8px;
  }

  .camera-container video {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
  }

  .camera-overlay {
    position: absolute;
    inset: 0;
    pointer-events: none;
  }

  .overlay-top, .overlay-bottom {
    position: absolute;
    left: 0; right: 0;
    background: rgba(0, 0, 0, 0.55);
  }
  .overlay-top { top: 0; height: 34%; }
  .overlay-bottom { bottom: 0; height: 34%; }

  .overlay-left, .overlay-right {
    position: absolute;
    top: 34%;
    height: 32%;
    background: rgba(0, 0, 0, 0.55);
  }
  .overlay-left { left: 0; width: 17%; }
  .overlay-right { right: 0; width: 17%; }

  .guide-strip {
    position: absolute;
    top: 34%;
    left: 17%;
    right: 17%;
    height: 32%;
    border: 2px solid rgba(255, 255, 255, 0.7);
    border-radius: 6px;
    overflow: hidden;
  }

  .guide-strip .corner {
    position: absolute;
    width: 14px;
    height: 14px;
    border-color: #fff;
    border-style: solid;
    z-index: 2;
  }
  .corner.tl { top: -2px; left: -2px; border-width: 3px 0 0 3px; border-radius: 4px 0 0 0; }
  .corner.tr { top: -2px; right: -2px; border-width: 3px 3px 0 0; border-radius: 0 4px 0 0; }
  .corner.bl { bottom: -2px; left: -2px; border-width: 0 0 3px 3px; border-radius: 0 0 0 4px; }
  .corner.br { bottom: -2px; right: -2px; border-width: 0 3px 3px 0; border-radius: 0 0 4px 0; }

  .guide-text {
    position: absolute;
    bottom: -22px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.65rem;
    color: rgba(255,255,255,0.7);
    white-space: nowrap;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    z-index: 2;
  }

  /* Barcode canvas inside the guide strip */
  #barcodeCanvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
  }

  .camera-placeholder {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: var(--text-dim);
    gap: 8px;
    font-size: 0.85rem;
    text-align: center;
    padding: 20px;
  }
  .camera-placeholder svg { width: 48px; height: 48px; opacity: 0.5; }

  /* Capture Button */
  .capture-btn {
    width: 100%;
    padding: 16px;
    border: none;
    border-radius: var(--radius);
    font-size: 1.1rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s;
    -webkit-tap-highlight-color: transparent;
    margin-bottom: 12px;
  }
  .capture-btn.live {
    background: var(--accent);
    color: #fff;
  }
  .capture-btn.live:active { transform: scale(0.97); opacity: 0.9; }
  .capture-btn.captured {
    background: var(--surface2);
    color: var(--text);
    border: 1px solid rgba(255,255,255,0.15);
  }

  /* Toggle buttons shared style */
  .toggle-row {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
    background: var(--surface);
    border-radius: var(--radius);
    padding: 4px;
  }
  .toggle-row button {
    flex: 1;
    padding: 10px;
    border: none;
    border-radius: 8px;
    background: transparent;
    color: var(--text-dim);
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
  }
  .toggle-row button.active {
    background: var(--surface2);
    color: #fff;
  }

  /* Band Selectors */
  .band-selectors {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-bottom: 16px;
  }

  .band-row {
    background: var(--surface);
    border-radius: var(--radius);
    padding: 10px 12px;
  }
  .band-row-label {
    font-size: 0.7rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.06em;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .band-row-label .band-indicator {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    border: 2px solid var(--text-dim);
    flex-shrink: 0;
  }

  .color-circles {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .color-circle {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: 3px solid transparent;
    cursor: pointer;
    transition: all 0.15s;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    -webkit-tap-highlight-color: transparent;
  }
  .color-circle:active { transform: scale(0.9); }
  .color-circle.selected {
    border-color: #fff;
    box-shadow: 0 0 0 2px var(--accent), 0 2px 8px rgba(233,69,96,0.4);
    transform: scale(1.1);
  }
  .color-circle .color-label {
    display: none;
    position: absolute;
    bottom: -18px;
    font-size: 0.55rem;
    color: var(--text-dim);
    white-space: nowrap;
  }
  .color-circle.selected .color-label { display: block; }
  .color-circle.none-band {
    border: 3px dashed var(--text-dim);
    background: transparent !important;
    font-size: 0.65rem;
    color: var(--text-dim);
  }

  /* Detected colors indicator */
  .detected-tag {
    display: inline-block;
    font-size: 0.55rem;
    background: var(--accent);
    color: #fff;
    padding: 1px 5px;
    border-radius: 4px;
    margin-left: 6px;
    vertical-align: middle;
  }

  /* Resistor Diagram */
  .resistor-diagram {
    background: var(--surface);
    border-radius: var(--radius);
    padding: 16px;
    margin-bottom: 16px;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 70px;
  }
  .resistor-svg { width: 100%; max-width: 320px; height: 60px; }

  /* Result Display */
  .result-display {
    background: var(--surface);
    border-radius: var(--radius);
    padding: 20px;
    text-align: center;
    margin-bottom: 16px;
    min-height: 80px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    gap: 4px;
  }
  .result-display.has-value { border: 1px solid var(--surface2); }
  .result-main { font-size: 1.8rem; font-weight: 700; letter-spacing: -0.02em; }
  .result-raw { font-size: 0.9rem; color: var(--text-dim); }
  .result-placeholder { color: var(--text-dim); font-size: 0.9rem; }

  .reset-btn {
    width: 100%;
    padding: 14px;
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: var(--radius);
    background: var(--surface);
    color: var(--text);
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
  }
  .reset-btn:active { background: var(--surface2); transform: scale(0.98); }
</style>
</head>
<body>
<header>
  <h1>Resistor Value Reader</h1>
  <p>Line up resistor, then capture to read</p>
</header>

<main>
  <!-- Camera Feed -->
  <div class="camera-container">
    <video id="cameraFeed" autoplay playsinline muted></video>
    <canvas id="hiddenCanvas" style="display:none"></canvas>
    <div class="camera-placeholder" id="cameraPlaceholder">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
        <path d="M23 19a2 2 0 01-2 2H3a2 2 0 01-2-2V8a2 2 0 012-2h4l2-3h6l2 3h4a2 2 0 012 2z"/>
        <circle cx="12" cy="13" r="4"/>
      </svg>
      <span>Tap to start camera</span>
    </div>
    <div class="camera-overlay" id="cameraOverlay" style="display:none">
      <div class="overlay-top"></div>
      <div class="overlay-bottom"></div>
      <div class="overlay-left"></div>
      <div class="overlay-right"></div>
      <div class="guide-strip" id="guideStrip">
        <canvas id="barcodeCanvas"></canvas>
        <div class="corner tl"></div>
        <div class="corner tr"></div>
        <div class="corner bl"></div>
        <div class="corner br"></div>
        <span class="guide-text">Line up resistor here</span>
      </div>
    </div>
  </div>

  <!-- Capture / Re-scan Button -->
  <button class="capture-btn live" id="captureBtn">Capture &amp; Analyze</button>

  <!-- Lens Picker -->
  <div class="toggle-row" id="lensPicker" style="display:none"></div>

  <!-- Band Type Toggle -->
  <div class="toggle-row">
    <button class="active" data-bands="4">4-Band</button>
    <button data-bands="5">5-Band</button>
  </div>

  <!-- Band Color Selectors -->
  <div class="band-selectors" id="bandSelectors"></div>

  <!-- Resistor Diagram Preview -->
  <div class="resistor-diagram" id="resistorDiagram"></div>

  <!-- Result Display -->
  <div class="result-display" id="resultDisplay">
    <span class="result-placeholder">Capture a resistor to read its value</span>
  </div>

  <!-- Reset -->
  <button class="reset-btn" id="resetBtn">Reset</button>

  <!-- Debug Panel -->
  <div style="margin-top:16px;position:relative;">
    <button id="copyDebugBtn" style="position:absolute;top:8px;right:8px;z-index:1;padding:6px 12px;border:1px solid #555;border-radius:6px;background:#333;color:#0f0;font-family:monospace;font-size:0.65rem;cursor:pointer;">Copy</button>
    <div id="debugPanel" style="padding:12px;padding-top:36px;background:#1a1a1a;border:1px solid #333;border-radius:8px;font-family:monospace;font-size:0.7rem;color:#0f0;max-height:200px;overflow-y:auto;word-break:break-all;"></div>
  </div>
</main>

<script>
(function() {
  'use strict';

  // ── Color definitions with HSL ranges for detection ──
  // Each has: name, resistor value, display bg, and HSL matching ranges
  const BAND_COLORS = [
    { name: 'Black',  digit: 0, mult: 1,    bg: '#111',    hsl: { hRange: [0,360], sRange: [0,20],  lRange: [0,15] } },
    { name: 'Brown',  digit: 1, mult: 10,   bg: '#8B4513', hsl: { hRange: [10,40], sRange: [20,80], lRange: [15,40] } },
    { name: 'Red',    digit: 2, mult: 100,  bg: '#e53935', hsl: { hRange: [345,20], sRange: [40,100], lRange: [30,60] } }, // wraps around 0
    { name: 'Orange', digit: 3, mult: 1e3,  bg: '#FF8C00', hsl: { hRange: [20,45],  sRange: [60,100], lRange: [40,70] } },
    { name: 'Yellow', digit: 4, mult: 1e4,  bg: '#FFD600', hsl: { hRange: [45,70],  sRange: [50,100], lRange: [50,85] } },
    { name: 'Green',  digit: 5, mult: 1e5,  bg: '#43A047', hsl: { hRange: [80,165], sRange: [25,100], lRange: [20,60] } },
    { name: 'Blue',   digit: 6, mult: 1e6,  bg: '#1E88E5', hsl: { hRange: [190,260],sRange: [30,100], lRange: [25,60] } },
    { name: 'Violet', digit: 7, mult: 1e7,  bg: '#8E24AA', hsl: { hRange: [260,310],sRange: [20,100], lRange: [20,55] } },
    { name: 'Grey',   digit: 8, mult: null, bg: '#757575', hsl: { hRange: [0,360], sRange: [0,15],   lRange: [30,65] } },
    { name: 'White',  digit: 9, mult: null, bg: '#f5f5f5', hsl: { hRange: [0,360], sRange: [0,25],   lRange: [75,100] } },
    { name: 'Gold',   digit: null, mult: 0.1,  bg: '#CFB53B', hsl: { hRange: [35,55], sRange: [30,80], lRange: [40,65] } },
    { name: 'Silver', digit: null, mult: 0.01, bg: '#C0C0C0', hsl: { hRange: [0,360], sRange: [0,15], lRange: [65,85] } },
  ];

  const TOLERANCE_MAP = {
    'Brown': 1, 'Red': 2, 'Green': 0.5, 'Blue': 0.25,
    'Violet': 0.1, 'Gold': 5, 'Silver': 10, 'None': 20
  };

  const DIGIT_COLORS = BAND_COLORS.filter(c => c.digit !== null);
  const MULTIPLIER_COLORS = BAND_COLORS.filter(c => c.mult !== null);
  const TOLERANCE_COLORS = [
    { name: 'Brown',  tol: 1,    bg: '#8B4513' },
    { name: 'Red',    tol: 2,    bg: '#e53935' },
    { name: 'Green',  tol: 0.5,  bg: '#43A047' },
    { name: 'Blue',   tol: 0.25, bg: '#1E88E5' },
    { name: 'Violet', tol: 0.1,  bg: '#8E24AA' },
    { name: 'Gold',   tol: 5,    bg: '#CFB53B' },
    { name: 'Silver', tol: 10,   bg: '#C0C0C0' },
    { name: 'None',   tol: 20,   bg: null },
  ];

  // ── State ──
  let bandCount = 4;
  let selections = {};
  let isCaptured = false;
  let animFrameId = null;

  // ── DOM refs ──
  const video = document.getElementById('cameraFeed');
  const hiddenCanvas = document.getElementById('hiddenCanvas');
  const hiddenCtx = hiddenCanvas.getContext('2d', { willReadFrequently: true });
  const barcodeCanvas = document.getElementById('barcodeCanvas');
  const barcodeCtx = barcodeCanvas.getContext('2d');
  const placeholder = document.getElementById('cameraPlaceholder');
  const overlay = document.getElementById('cameraOverlay');
  const guideStrip = document.getElementById('guideStrip');
  const captureBtn = document.getElementById('captureBtn');
  const selectorsEl = document.getElementById('bandSelectors');
  const diagramEl = document.getElementById('resistorDiagram');
  const resultEl = document.getElementById('resultDisplay');
  const resetBtn = document.getElementById('resetBtn');
  const toggleBtns = document.querySelectorAll('.toggle-row button[data-bands]');
  const lensPickerEl = document.getElementById('lensPicker');

  // ── Debug ──
  const debugEl = document.getElementById('debugPanel');
  const copyDebugBtn = document.getElementById('copyDebugBtn');
  function dbg(msg) {
    const t = new Date().toLocaleTimeString();
    debugEl.innerHTML += `<div>[${t}] ${msg}</div>`;
    debugEl.scrollTop = debugEl.scrollHeight;
  }
  copyDebugBtn.addEventListener('click', () => {
    const text = debugEl.innerText;
    navigator.clipboard.writeText(text).then(() => {
      copyDebugBtn.textContent = 'Copied!';
      setTimeout(() => { copyDebugBtn.textContent = 'Copy'; }, 1500);
    }).catch(() => {
      // Fallback for iOS
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.style.position = 'fixed';
      ta.style.opacity = '0';
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      copyDebugBtn.textContent = 'Copied!';
      setTimeout(() => { copyDebugBtn.textContent = 'Copy'; }, 1500);
    });
  });

  // ── Camera ──
  let currentDeviceId = null;
  let allCameras = [];

  dbg('Page loaded. UA: ' + navigator.userAgent.slice(0, 80));
  dbg('Secure context: ' + window.isSecureContext);

  async function applyMacroFocus(stream) {
    const track = stream.getVideoTracks()[0];
    if (!track.getCapabilities) { dbg('getCapabilities not supported'); return; }
    const caps = track.getCapabilities();
    dbg('Focus modes: ' + JSON.stringify(caps.focusMode || 'n/a'));
    dbg('Focus dist: ' + JSON.stringify(caps.focusDistance || 'n/a'));
    const constraints = {};
    if (caps.focusDistance) {
      const minDist = caps.focusDistance.min;
      constraints.focusMode = 'manual';
      constraints.focusDistance = minDist + (caps.focusDistance.max - minDist) * 0.02;
      dbg('Macro focus: ' + constraints.focusDistance.toFixed(3));
    } else if (caps.focusMode && caps.focusMode.includes('continuous')) {
      constraints.focusMode = 'continuous';
    }
    if (Object.keys(constraints).length) {
      try { await track.applyConstraints({ advanced: [constraints] }); dbg('Focus applied'); }
      catch (e) { dbg('Focus failed: ' + e.message); }
    }
  }

  async function enumerateCameras() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      allCameras = devices.filter(d => d.kind === 'videoinput');
      dbg('Cameras: ' + allCameras.length);
      allCameras.forEach((c, i) => dbg('  [' + i + '] ' + (c.label || 'Cam ' + i)));

      let macroIdx = allCameras.findIndex(c => /ultra.?wide/i.test(c.label));

      if (allCameras.length > 1) {
        lensPickerEl.style.display = 'flex';
        lensPickerEl.innerHTML = '';
        allCameras.forEach((cam, i) => {
          const btn = document.createElement('button');
          const label = cam.label || ('Camera ' + i);
          if (/ultra/i.test(label)) btn.textContent = 'Macro (UW)';
          else if (/tele/i.test(label)) btn.textContent = 'Tele';
          else if (/wide/i.test(label) && !/ultra/i.test(label)) btn.textContent = 'Wide';
          else if (/front/i.test(label)) btn.textContent = 'Front';
          else btn.textContent = 'Lens ' + i;
          btn.title = label;
          if (cam.deviceId === currentDeviceId) btn.classList.add('active');
          btn.addEventListener('click', () => switchToCamera(cam.deviceId));
          lensPickerEl.appendChild(btn);
        });
      }

      if (macroIdx !== -1 && allCameras[macroIdx].deviceId !== currentDeviceId) {
        dbg('Auto-switching to macro lens...');
        await switchToCamera(allCameras[macroIdx].deviceId);
      }
    } catch (e) { dbg('enumerate failed: ' + e.message); }
  }

  function stopCurrentStream() {
    if (video.srcObject) {
      video.srcObject.getTracks().forEach(t => t.stop());
      video.srcObject = null;
    }
  }

  async function switchToCamera(deviceId) {
    dbg('Switch to: ' + (deviceId || 'default').slice(0, 12));
    stopCurrentStream();
    currentDeviceId = deviceId;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { deviceId: { exact: deviceId }, width: { ideal: 1280 }, height: { ideal: 960 } }
      });
      video.srcObject = stream;
      placeholder.style.display = 'none';
      overlay.style.display = 'block';
      await applyMacroFocus(stream);
      lensPickerEl.querySelectorAll('button').forEach(b => b.classList.remove('active'));
      allCameras.forEach((c, i) => { if (c.deviceId === deviceId) lensPickerEl.children[i]?.classList.add('active'); });
      if (!isCaptured) startBarcodeLoop();
    } catch (e) { dbg('Switch failed: ' + e.message); }
  }

  async function startCamera() {
    dbg('startCamera()');
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      placeholder.querySelector('span').textContent = 'Camera API not available';
      return;
    }
    try {
      // Simple approach that always worked: just ask for rear camera
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 960 } }
      });
      const track = stream.getVideoTracks()[0];
      currentDeviceId = track.getSettings().deviceId || null;
      dbg('Started on: ' + track.label);
      video.srcObject = stream;
      placeholder.style.display = 'none';
      overlay.style.display = 'block';
      startBarcodeLoop();

      // Now that we have permission, enumerate cameras for the lens picker
      const devices = await navigator.mediaDevices.enumerateDevices();
      allCameras = devices.filter(d => d.kind === 'videoinput');
      dbg('Cameras: ' + allCameras.length);
      allCameras.forEach((c, i) => dbg('  [' + i + '] ' + (c.label || 'Cam ' + i)));

      // Build lens picker (skip front cameras)
      if (allCameras.length > 1) {
        lensPickerEl.style.display = 'flex';
        lensPickerEl.innerHTML = '';
        allCameras.forEach((cam, i) => {
          const label = cam.label || ('Camera ' + i);
          if (/front/i.test(label)) return;
          const btn = document.createElement('button');
          if (/ultra/i.test(label)) btn.textContent = 'Macro (UW)';
          else if (/tele/i.test(label)) btn.textContent = 'Tele';
          else if (/wide/i.test(label)) btn.textContent = 'Wide';
          else btn.textContent = 'Lens ' + i;
          btn.title = label;
          if (cam.deviceId === currentDeviceId) btn.classList.add('active');
          btn.addEventListener('click', () => switchToCamera(cam.deviceId));
          lensPickerEl.appendChild(btn);
        });
      }

      // Auto-switch to ultra-wide (macro) if available
      const macroIdx = allCameras.findIndex(c => /ultra.?wide/i.test(c.label));
      if (macroIdx !== -1 && allCameras[macroIdx].deviceId !== currentDeviceId) {
        dbg('Switching to macro lens...');
        await switchToCamera(allCameras[macroIdx].deviceId);
      }
    } catch (e) {
      dbg('Failed: ' + e.message);
      placeholder.querySelector('span').textContent = 'Camera not available';
    }
  }

  placeholder.addEventListener('click', startCamera);
  startCamera();

  // ── Live Barcode Effect ──
  // Sample center row of the guide strip region from the video,
  // then repeat it vertically to fill the strip = live barcode
  function startBarcodeLoop() {
    if (animFrameId) cancelAnimationFrame(animFrameId);

    function loop() {
      if (isCaptured) return;
      if (video.readyState >= 2) {
        drawBarcode();
      }
      animFrameId = requestAnimationFrame(loop);
    }
    animFrameId = requestAnimationFrame(loop);
  }

  function drawBarcode() {
    const vw = video.videoWidth;
    const vh = video.videoHeight;
    if (!vw || !vh) return;

    // Guide strip region in video coordinates
    // Strip is at: top 42%, height 16%, left 10%, right 10%
    const stripTop = Math.floor(vh * 0.34);
    const stripH = Math.floor(vh * 0.32);
    const stripLeft = Math.floor(vw * 0.17);
    const stripW = Math.floor(vw * 0.66);
    const centerY = stripTop + Math.floor(stripH / 2);

    // Draw full frame to hidden canvas
    hiddenCanvas.width = vw;
    hiddenCanvas.height = vh;
    hiddenCtx.drawImage(video, 0, 0, vw, vh);

    // Sample one horizontal row of pixels from center of strip
    const rowData = hiddenCtx.getImageData(stripLeft, centerY, stripW, 1);

    // Size barcode canvas to match the guide strip element
    const rect = guideStrip.getBoundingClientRect();
    const cw = Math.floor(rect.width);
    const ch = Math.floor(rect.height);
    if (cw < 1 || ch < 1) return;

    if (barcodeCanvas.width !== cw || barcodeCanvas.height !== ch) {
      barcodeCanvas.width = cw;
      barcodeCanvas.height = ch;
    }

    // Draw the single row stretched vertically to fill the strip
    // Create a 1-pixel-high ImageData from the sampled row, put it, then stretch
    const oneRow = barcodeCtx.createImageData(cw, 1);
    // Resample the row to fit canvas width
    for (let x = 0; x < cw; x++) {
      const srcX = Math.floor(x * stripW / cw);
      const si = srcX * 4;
      const di = x * 4;
      oneRow.data[di]     = rowData.data[si];
      oneRow.data[di + 1] = rowData.data[si + 1];
      oneRow.data[di + 2] = rowData.data[si + 2];
      oneRow.data[di + 3] = 255;
    }

    // Put the row at y=0, then draw it stretched to full height
    barcodeCtx.putImageData(oneRow, 0, 0);
    barcodeCtx.drawImage(barcodeCanvas, 0, 0, cw, 1, 0, 0, cw, ch);
  }

  // ── Capture & Analyze ──
  captureBtn.addEventListener('click', () => {
    if (!isCaptured) {
      capture();
    } else {
      resumeLive();
    }
  });

  function capture() {
    if (!video.srcObject) return;
    isCaptured = true;
    if (animFrameId) cancelAnimationFrame(animFrameId);

    captureBtn.textContent = 'Re-scan';
    captureBtn.classList.remove('live');
    captureBtn.classList.add('captured');

    // Freeze: draw current barcode one last time then analyze
    drawBarcode();
    video.pause();

    dbg('Captured! Analyzing...');
    analyzeBarcode();
  }

  function resumeLive() {
    isCaptured = false;
    video.play();
    captureBtn.textContent = 'Capture & Analyze';
    captureBtn.classList.remove('captured');
    captureBtn.classList.add('live');
    selections = {};
    renderSelectors();
    updateResult();
    startBarcodeLoop();
  }

  // ── Color Analysis ──
  function rgbToHsl(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
        case g: h = ((b - r) / d + 2) / 6; break;
        case b: h = ((r - g) / d + 4) / 6; break;
      }
    }
    return [h * 360, s * 100, l * 100];
  }

  function matchColor(r, g, b) {
    const [h, s, l] = rgbToHsl(r, g, b);
    let bestMatch = null;
    let bestScore = Infinity;

    for (const color of BAND_COLORS) {
      const hr = color.hsl.hRange;
      const sr = color.hsl.sRange;
      const lr = color.hsl.lRange;

      // Check if HSL falls within range (handle hue wrapping for red)
      let hMatch;
      if (hr[0] > hr[1]) {
        // Wraps around (e.g., red: 345-20)
        hMatch = h >= hr[0] || h <= hr[1];
      } else {
        hMatch = h >= hr[0] && h <= hr[1];
      }
      const sMatch = s >= sr[0] && s <= sr[1];
      const lMatch = l >= lr[0] && l <= lr[1];

      if (hMatch && sMatch && lMatch) {
        // Score by distance to center of ranges
        const hCenter = hr[0] > hr[1] ? ((hr[0] + hr[1] + 360) / 2) % 360 : (hr[0] + hr[1]) / 2;
        let hDist = Math.abs(h - hCenter);
        if (hDist > 180) hDist = 360 - hDist;
        const sDist = Math.abs(s - (sr[0] + sr[1]) / 2);
        const lDist = Math.abs(l - (lr[0] + lr[1]) / 2);
        const score = hDist + sDist + lDist;
        if (score < bestScore) {
          bestScore = score;
          bestMatch = color;
        }
      }
    }
    return bestMatch;
  }

  function analyzeBarcode() {
    const vw = video.videoWidth;
    const vh = video.videoHeight;
    if (!vw || !vh) { dbg('No video data'); return; }

    const stripLeft = Math.floor(vw * 0.17);
    const stripW = Math.floor(vw * 0.66);
    const centerY = Math.floor(vh * 0.34 + vh * 0.16); // center of strip

    // Sample a few rows around center for robustness and average
    const sampleRows = 5;
    const pixels = [];
    for (let x = 0; x < stripW; x++) {
      let rSum = 0, gSum = 0, bSum = 0;
      for (let dy = -2; dy <= 2; dy++) {
        const data = hiddenCtx.getImageData(stripLeft + x, centerY + dy, 1, 1).data;
        rSum += data[0]; gSum += data[1]; bSum += data[2];
      }
      pixels.push([
        Math.round(rSum / sampleRows),
        Math.round(gSum / sampleRows),
        Math.round(bSum / sampleRows)
      ]);
    }

    // Classify each pixel
    const colorLabels = pixels.map(([r, g, b]) => {
      const match = matchColor(r, g, b);
      return match ? match.name : '?';
    });

    dbg('Pixel colors (sampled): ' + colorLabels.filter((_, i) => i % 20 === 0).join(','));

    // Find runs of consistent color (bands)
    const runs = [];
    let currentRun = { color: colorLabels[0], start: 0, count: 1 };
    for (let i = 1; i < colorLabels.length; i++) {
      if (colorLabels[i] === currentRun.color) {
        currentRun.count++;
      } else {
        runs.push(currentRun);
        currentRun = { color: colorLabels[i], start: i, count: 1 };
      }
    }
    runs.push(currentRun);

    dbg('Runs: ' + runs.map(r => r.color + '(' + r.count + ')').join(', '));

    // Filter out tiny noise runs (less than 2% of strip width) and the resistor body color
    const minRunWidth = Math.floor(stripW * 0.02);
    const significantRuns = runs.filter(r => r.count >= minRunWidth);

    dbg('Significant runs: ' + significantRuns.map(r => r.color + '(' + r.count + ')').join(', '));

    // Find the body color (usually the most common non-band color, typically brown/tan/beige)
    // Bands are the colored stripes that are NOT the body
    // Strategy: the body color will likely be the longest total run
    const colorTotals = {};
    significantRuns.forEach(r => {
      colorTotals[r.color] = (colorTotals[r.color] || 0) + r.count;
    });

    // Sort by total pixels descending - most common is likely the body
    const sortedColors = Object.entries(colorTotals).sort((a, b) => b[1] - a[1]);
    const bodyColor = sortedColors.length > 0 ? sortedColors[0][0] : null;
    dbg('Likely body color: ' + bodyColor);

    // Bands are everything that's NOT the body color, in order
    const detectedBands = significantRuns
      .filter(r => r.color !== bodyColor && r.color !== '?')
      .map(r => r.color);

    dbg('Detected bands: ' + detectedBands.join(', '));

    if (detectedBands.length < 3) {
      dbg('Not enough bands detected (' + detectedBands.length + '). Try adjusting alignment.');
      resultEl.innerHTML = '<span class="result-placeholder">Could not detect enough bands. Adjust and try again.</span>';
      return;
    }

    // Map detected colors to band selections
    applyDetectedBands(detectedBands);
  }

  function applyDetectedBands(detectedBands) {
    const config = getBandConfig();
    const expected = config.length;

    // Take the right number of bands
    let bands = detectedBands;
    if (bands.length > expected) {
      // Take the first N bands
      bands = bands.slice(0, expected);
    }

    dbg('Applying ' + bands.length + ' bands (need ' + expected + '): ' + bands.join(', '));

    // Map each detected band to the correct selector index
    bands.forEach((colorName, i) => {
      if (i >= config.length) return;
      const bandCfg = config[i];
      const colorList = getColorsForType(bandCfg.type);
      const idx = colorList.findIndex(c => c.name === colorName);
      if (idx !== -1) {
        selections[bandCfg.key] = idx;
      } else {
        dbg('No match for ' + colorName + ' in ' + bandCfg.type + ' band');
      }
    });

    renderSelectors(true);
    updateResult();
  }

  // ── Band type toggle ──
  toggleBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      toggleBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      bandCount = parseInt(btn.dataset.bands);
      selections = {};
      renderSelectors();
      updateResult();
    });
  });

  // ── Band selector UI ──
  function getBandConfig() {
    if (bandCount === 4) {
      return [
        { key: 'band0', label: 'Band 1 \u2014 1st Digit',  type: 'digit' },
        { key: 'band1', label: 'Band 2 \u2014 2nd Digit',  type: 'digit' },
        { key: 'band2', label: 'Band 3 \u2014 Multiplier', type: 'multiplier' },
        { key: 'band3', label: 'Band 4 \u2014 Tolerance',  type: 'tolerance' },
      ];
    }
    return [
      { key: 'band0', label: 'Band 1 \u2014 1st Digit',  type: 'digit' },
      { key: 'band1', label: 'Band 2 \u2014 2nd Digit',  type: 'digit' },
      { key: 'band2', label: 'Band 3 \u2014 3rd Digit',  type: 'digit' },
      { key: 'band3', label: 'Band 4 \u2014 Multiplier', type: 'multiplier' },
      { key: 'band4', label: 'Band 5 \u2014 Tolerance',  type: 'tolerance' },
    ];
  }

  function getColorsForType(type) {
    if (type === 'digit') return DIGIT_COLORS.map(c => ({ name: c.name, value: c.digit, bg: c.bg }));
    if (type === 'multiplier') return MULTIPLIER_COLORS.map(c => {
      let label;
      if (c.mult >= 1e6) label = (c.mult/1e6) + ' M\u03A9';
      else if (c.mult >= 1e3) label = (c.mult/1e3) + ' k\u03A9';
      else label = c.mult + ' \u03A9';
      return { name: c.name, mult: c.mult, bg: c.bg, label: '\u00D7' + label };
    });
    return TOLERANCE_COLORS;
  }

  function renderSelectors(detected) {
    const config = getBandConfig();
    selectorsEl.innerHTML = '';

    config.forEach(band => {
      const row = document.createElement('div');
      row.className = 'band-row';

      const colors = getColorsForType(band.type);
      const selectedColor = selections[band.key] !== undefined ? colors[selections[band.key]] : null;
      const indicatorBg = selectedColor ? (selectedColor.bg || 'transparent') : 'transparent';

      const detectedTag = detected && selections[band.key] !== undefined
        ? '<span class="detected-tag">detected</span>' : '';

      row.innerHTML = `<div class="band-row-label">
        <span class="band-indicator" style="background:${indicatorBg};${selectedColor ? 'border-color:' + indicatorBg : ''}"></span>
        ${band.label}${detectedTag}
      </div>`;

      const circlesDiv = document.createElement('div');
      circlesDiv.className = 'color-circles';

      colors.forEach((color, i) => {
        const circle = document.createElement('button');
        circle.className = 'color-circle';
        if (selections[band.key] === i) circle.classList.add('selected');

        if (color.bg === null) {
          circle.classList.add('none-band');
          circle.textContent = '\u2205';
        } else {
          circle.style.background = color.bg;
        }

        const labelEl = document.createElement('span');
        labelEl.className = 'color-label';
        if (band.type === 'digit') labelEl.textContent = color.value;
        else if (band.type === 'multiplier') labelEl.textContent = color.label;
        else labelEl.textContent = '\u00B1' + color.tol + '%';
        circle.appendChild(labelEl);

        circle.addEventListener('click', () => {
          selections[band.key] = i;
          renderSelectors();
          updateResult();
        });
        circlesDiv.appendChild(circle);
      });

      row.appendChild(circlesDiv);
      selectorsEl.appendChild(row);
    });
  }

  // ── Resistor Diagram ──
  function renderDiagram() {
    const config = getBandConfig();
    const colors = getColorsForType;
    const bandColors = config.map(b => {
      if (selections[b.key] === undefined) return '#444';
      const c = getColorsForType(b.type)[selections[b.key]];
      return c.bg || '#ddd';
    });

    const w = 320, h = 60;
    const bodyX = 60, bodyW = 200, bodyH = 36, bodyY = (h - bodyH) / 2;
    const wireY = h / 2;
    let svg = `<svg class="resistor-svg" viewBox="0 0 ${w} ${h}" xmlns="http://www.w3.org/2000/svg">`;
    svg += `<line x1="0" y1="${wireY}" x2="${bodyX}" y2="${wireY}" stroke="#aaa" stroke-width="2.5"/>`;
    svg += `<line x1="${bodyX + bodyW}" y1="${wireY}" x2="${w}" y2="${wireY}" stroke="#aaa" stroke-width="2.5"/>`;
    svg += `<rect x="${bodyX}" y="${bodyY}" width="${bodyW}" height="${bodyH}" rx="6" fill="#D2B48C"/>`;
    svg += `<rect x="${bodyX}" y="${bodyY}" width="${bodyW}" height="${bodyH}" rx="6" fill="none" stroke="#B8956A" stroke-width="1"/>`;

    const n = bandColors.length;
    const bandW = 14;
    const gap = (bodyW - 30 - n * bandW) / (n - 1);
    bandColors.forEach((color, i) => {
      const x = bodyX + 15 + i * (bandW + gap);
      svg += `<rect x="${x}" y="${bodyY + 3}" width="${bandW}" height="${bodyH - 6}" rx="2" fill="${color}" stroke="rgba(0,0,0,0.2)" stroke-width="0.5"/>`;
    });

    svg += '</svg>';
    diagramEl.innerHTML = svg;
  }

  // ── Value Calculation ──
  function formatResistance(ohms) {
    if (ohms >= 1e9) return (ohms / 1e9).toPrecision(3) + ' G\u03A9';
    if (ohms >= 1e6) return (ohms / 1e6).toPrecision(3) + ' M\u03A9';
    if (ohms >= 1e3) return (ohms / 1e3).toPrecision(3) + ' k\u03A9';
    if (ohms >= 1)   return ohms.toPrecision(3) + ' \u03A9';
    if (ohms >= 0.001) return (ohms * 1000).toPrecision(3) + ' m\u03A9';
    return ohms + ' \u03A9';
  }

  function formatRaw(ohms) {
    if (ohms >= 1) {
      if (Number.isInteger(ohms)) return ohms.toLocaleString() + ' \u03A9';
      return ohms.toLocaleString(undefined, { maximumFractionDigits: 2 }) + ' \u03A9';
    }
    return ohms + ' \u03A9';
  }

  function updateResult() {
    renderDiagram();
    const config = getBandConfig();
    const allSelected = config.every(b => selections[b.key] !== undefined);

    if (!allSelected) {
      const count = config.filter(b => selections[b.key] !== undefined).length;
      if (count > 0) {
        resultEl.innerHTML = '<span class="result-placeholder">' + count + '/' + config.length + ' bands detected \u2014 select remaining bands</span>';
      } else {
        resultEl.innerHTML = '<span class="result-placeholder">Capture a resistor to read its value</span>';
      }
      resultEl.classList.remove('has-value');
      return;
    }

    let digits, multIdx, tolIdx;
    const digitColors = getColorsForType('digit');
    const multColors = getColorsForType('multiplier');
    const tolColors = getColorsForType('tolerance');

    if (bandCount === 4) {
      digits = digitColors[selections.band0].value * 10 + digitColors[selections.band1].value;
      multIdx = selections.band2;
      tolIdx = selections.band3;
    } else {
      digits = digitColors[selections.band0].value * 100 + digitColors[selections.band1].value * 10 + digitColors[selections.band2].value;
      multIdx = selections.band3;
      tolIdx = selections.band4;
    }

    const mult = multColors[multIdx].mult;
    const tol = tolColors[tolIdx].tol;
    const ohms = digits * mult;

    resultEl.innerHTML = `
      <div class="result-main">${formatResistance(ohms)} \u00B1${tol}%</div>
      <div class="result-raw">${formatRaw(ohms)}</div>
    `;
    resultEl.classList.add('has-value');
  }

  // ── Reset ──
  resetBtn.addEventListener('click', () => {
    if (isCaptured) resumeLive();
    selections = {};
    renderSelectors();
    updateResult();
  });

  // ── Init ──
  renderSelectors();
  updateResult();
})();
</script>
</body>
</html>
